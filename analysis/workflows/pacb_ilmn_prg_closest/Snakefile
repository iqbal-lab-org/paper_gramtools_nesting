"""
This workflow finds the closest input sequence to a fasta assembly. In context of pacb_ilmn_validation workflow, we find the closest prg input sequence to give a minimal target for gramtools inferred personalised reference.

This workflow regenerates sequences from vcfs using same rules as make_prgs workflow because it needs to use the same gene lengths as pacb_ilmn_validation (ie without 5kb flanks for eg)
"""

from pathlib import Path

WORKFLOW = "pacb_ilmn_prg_closest"

configfile: "analysis/configs/common.yaml"
configfile: "analysis/configs/pacb_ilmn_validation/pfalciparum.yaml"
configfile: "analysis/configs/make_prgs/pfalciparum.yaml"


# Get assemblies to process
include: "../pacb_ilmn_validation/utils.py"
excluded = {'3D7', 'ML01'} # No ilmn reads for accession in Otto paper
ASSEMBLIES = get_samples(config["sample_tsv"], excluded)

# Get input prg vcfs to process
include: "../make_prgs/utils.py"
vcfs = load_vcf_names(config["pf_release_3"]["cortex_vcf_list"])

# Get genes to process
with open(config["starting_prg"]["gene_list"]) as f:
	GENES = f.read().splitlines()


#____Output paths___#
include: "../common_utils.py"
output_base = Path(f'{config["output_dir"]}/{WORKFLOW}/')
output_portions = output_base / "gene_portions"
output_seqs = output_base / "gene_sequences"
output_alignments = output_base / "alignments"
output_plots = output_base / "plots"
mk_output_dirs(dir())

#__Input paths__#
output_bowtie_indexes = Path(f'{config["output_dir"]}/pacb_ilmn_validation/bowtie_indexes')
GMTOOLS_COMMIT = get_gmtools_commit()
validation_stats = Path(f'{config["output_dir"]}/pacb_ilmn_validation/pf_4surfants/{GMTOOLS_COMMIT}/plots/stats.tsv')


rule all:
	input:
		expand(f'{output_plots}/{{gene}}_gmtools_delta.pdf',gene = GENES)


rule make_var_sample_portions:
	input:
		var_bed = config["starting_prg"]["var_regions"],
		ref_genome = config["pf_release_3"]["fasta"],
		vcf_file = lambda wildcards: vcfs[wildcards.sample]
	params:
		outdir=f"{output_portions}/{{sample}}"
	output:
		temp(expand(f"{output_portions}/{{sample}}/{{gene}}.fa",gene = GENES, allow_missing=True))
	shell:
		"""
		mkdir -p {params.outdir}
		clean_vcf={params.outdir}/clean.vcf
		bcftools view -f PASS {input.vcf_file} | bcftools norm -c x -f {input.ref_genome} -Oz > ${{clean_vcf}}.gz
		bcftools index ${{clean_vcf}}.gz
		IFS="\n"; for gene_line in $(cat {input.var_bed})
		do
			IFS="\t"; elems=($gene_line)	
			adj_start=$((${{elems[1]}} + 1))
			reg="${{elems[0]}}:${{adj_start}}-${{elems[2]}}"
			fout={params.outdir}/${{elems[3]}}.fa
			samtools faidx {input.ref_genome} $reg | bcftools consensus -s {wildcards.sample} ${{clean_vcf}}.gz |
				sed 's/>.*/>'{wildcards.sample}'/' > $fout
		done
		"""

rule cat_var_portions:
	input:
		samples=expand(f"{output_portions}/{{sample}}/{{gene}}.fa",sample=vcfs.keys(), allow_missing=True)
	output:
		seqs=f"{output_seqs}/{{gene}}.fa",
	run:
		with open(output.seqs, "w") as fout:
			for portion in input.samples:
				with open(portion) as fin:
					sequence = fin.read()	
				fout.write(sequence)

rule align_to_assemblies:
	input:
		gene_portions=rules.cat_var_portions.output.seqs,
		index=expand(f'{output_bowtie_indexes}/{{assembly}}.{{ext}}',ext=bowtie2_idx_extensions, allow_missing=True),
	output:
		alignment_file=f'{output_alignments}/{{assembly}}_{{gene}}.sam',
	params:
		index_prefix=f'{output_bowtie_indexes}/{{assembly}}',
	shell:
		"""
		bowtie2 -x {params.index_prefix} -U {input.gene_portions} -f > {output.alignment_file}
		"""

rule get_stats:
	input:
		alignment_file=f'{output_alignments}/{{assembly}}_{{gene}}.sam',
		var_bed = config["starting_prg"]["var_regions"],
	output:
		stats_file=f'{output_alignments}/{{assembly}}_{{gene}}.tsv',
	shell:
		"""
		gene_line=$(grep -w {wildcards.gene} {input.var_bed})
		IFS="\t"; elems=($gene_line)	
		gene_len=$((${{elems[2]}} - ${{elems[1]}} + 1))
		# Hack: these pipes sometimes have non-zero exit code, echo solves it
		all_NM=$(grep -Eo 'NM:i:[0-9]+' {input.alignment_file} | cut -f 3 -d ':' | sort -n)
		echo ""
		best_match=$(echo $all_NM | head -n 1)
		echo ""
		best_match_frac=$(echo $best_match / $gene_len | bc -l)
		echo -e "{wildcards.gene}\t{wildcards.assembly}\t${{best_match_frac}}\tclosest_in_prg"  > {output.stats_file}
		"""

rule concat_stats:
	input:
		expand(f'{output_alignments}/{{assembly}}_{{gene}}.tsv', assembly = ASSEMBLIES, gene = GENES)
	output:
		str(output_base / "stats.tsv")
	shell:
		"""
		echo "gene\tsample\tNM\tcondition\n" > {output}
		cat {input} >> {output}
		"""

rule plot_delta_NM:
	input:
		closest_prg_stats = rules.concat_stats.output,
		validation_stats = validation_stats,
	output:
		expand(f'{output_plots}/{{gene}}_gmtools_delta.pdf',gene = GENES)
	params:
		script=f'{config["scripts"]}/{WORKFLOW}/process_stats.py'
	shell:
		f"python3 {{params.script}} {{input.validation_stats}} {{input.closest_prg_stats}} {output_plots}"
		
