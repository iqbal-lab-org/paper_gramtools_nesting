"""
From a bed describing variant regions and non-var regions (prefixed by "nonvar_") and a directory containing one msa per var region in the bed, produce a vg prg. 

Assumptions: - the bed is ordered by genome chrom and pos
			 - each input msa has a ref fasta portion named 'ref'

These inputs are generated by the `make_prgs` workflow.

A note about vg construct calls: `-a` and `-S` options, for retaining alt paths and structural vars resp., don't make any difference to the produced graph, so not used.
"""
from pathlib import Path

WORKFLOW = "vg_make_prgs"

configfile: "analysis/configs/common.yaml"
configfile: "analysis/configs/vg_make_prgs.yaml"
#container: config["container"]

include: "../common_utils.py"
include: "../make_prgs/utils.py"

# Paths
output_base = Path(f'{config["output_dir"]}/{WORKFLOW}/{config["prg_name"]}')
output_prgs = output_base / "prgs"
output_vcfs = output_base / "vcfs"

mk_output_dirs(dir())

# Get list of regions to build prgs of
nonvar_regions, all_regions = [], []
cs_var_regions = "" # For use by bcftools merge
with open(config["full_bed"]) as f:
	for line in f:
		rows = line.split("\t")
		reg_name = rows[3].strip() 
		if reg_name.startswith("nonvar_"):
			nonvar_regions.append(reg_name)
		else:
			cs_var_regions += f'{rows[0]}:{int(rows[1]) + 1}-{rows[2]},'
		all_regions.append(reg_name)
			
vcfs = load_vcf_names(config["vcf_list"], config["prg_name"])

rule all:
	input:
		f"{output_base}/prg_msa.vg",
		f"{output_base}/prg_vcf.vg",

rule make_var_prgs:
	input:
		msa=Path(config["msa_dir"]) / '{region}.msa'
	output:
		prg=f'{output_prgs}/{{region}}.vg'
	resources:
		mem_mb=5000
	shell:
		"""
		vg construct -M {input.msa} > {output.prg}
		"""

			
rule make_nonvar_prgs:
	input:	
		full_bed = config["full_bed"],
		ref_genome = config["genome_fasta"],
	output:
		expand(f"{output_prgs}/{{region}}.vg", region = nonvar_regions),
	params:
		outdir=output_prgs,
	shadow: 
		"shallow"
	shell:
		"""
		IFS="\n"; for nonvar_line in $(grep -w "nonvar_.*" {input.full_bed}) 
		do
			IFS="\t"; elems=($nonvar_line)	
			adj_start=$((${{elems[1]}} + 1))
			prg_name="${{elems[3]}}"
			reg="${{elems[0]}}:${{adj_start}}-${{elems[2]}}"
			samtools faidx {input.ref_genome} $reg | \
				sed 's/>.*/>ref/' > ref_portion.fa
			vg construct -M ref_portion.fa > {params.outdir}/${{prg_name}}.vg
		done
		"""

rule concat_prgs:
	input:
		expand(f"{output_prgs}/{{region}}.vg", region = all_regions),
	output:
		f"{output_base}/prg.vg"
	resources:
		mem_mb=5000
	shell:
		"vg concat {input} > {output}"

rule make_input_vcf:
	input:
		vcfs=vcfs.values(),
	output:
		merged=f'{output_vcfs}/merged.vcf.gz',
	params:
		regions=cs_var_regions,
	shadow:
		"shallow"
	shell:
		"""
		i=0
		for in_vcf in {input.vcfs}; do
		if [[ $i == 0 ]]; then bcftools view -r {params.regions} -Oz -o {output.merged} $in_vcf
		else 
			bcftools merge -r {params.regions} -Oz -o tmp.vcf.gz $in_vcf {output.merged}
			mv tmp.vcf.gz {output.merged}
		fi
		"""

rule prg_from_vcf:
	input:
		vcf=rules.make_input_vcf.output.merged,
		ref_genome = config["genome_fasta"],
	output:
		f"{output_base}/prg_vcf.vg",
	shell:
		"vg construct -r {input.ref_genome} -v {input.vcf} -a > {output}"
